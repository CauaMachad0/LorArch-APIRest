trigger:
  branches:
    include:
      - main
      - master

pool:
  vmImage: 'ubuntu-latest'

variables:
  appName: 'myassist554611'
  acrName: 'acrlorch'
  acrLoginServer: 'acrlorch.azurecr.io'
  imageRepository: 'fiap/$(appName)'
  imageTag: '$(Build.BuildId)'
  dockerRegistryServiceConnection: 'sc-acr-lorch'
  azureServiceConnection: 'sc-azure-lorch'
  resourceGroup: 'LorArch'
  location: 'eastus'
  containerPort: '8080'
  # Secrets criar na UI: DB_URL, DB_USER, DB_PASSWORD

stages:
# =========================
# CI: Build & Push no ACR
# =========================
- stage: Build
  displayName: 'Build & Push'
  jobs:
    - job: build_push
      displayName: 'Build & Push image to ACR'
      steps:
        - checkout: self

        - task: Docker@2
          displayName: 'Build & Push image'
          inputs:
            containerRegistry: '$(dockerRegistryServiceConnection)'
            repository: '$(imageRepository)'
            command: 'buildAndPush'
            Dockerfile: '**/Dockerfile'
            tags: |
              $(imageTag)

        # Salva a referência da imagem como artifact (opcional, ajuda no debug)
        - script: |
            echo "IMAGE=$(acrLoginServer)/$(imageRepository):$(imageTag)" >> build_vars.txt
            cat build_vars.txt
          displayName: 'Persist image ref'

        - publish: build_vars.txt
          artifact: image_meta

# =========================
# CD: Deploy no ACI
# =========================
- stage: Deploy
  displayName: 'Deploy to ACI'
  dependsOn: Build
  jobs:
    - job: deploy_aci
      displayName: 'Deploy ACI'
      steps:
        - download: current
          artifact: image_meta

        # DEPLOY: cria/atualiza o ACI e exporta o FQDN como output
        - task: AzureCLI@2
          name: setfqdn               # <<< NOME DO PASSO (importante!)
          displayName: 'Deploy ACI (create/update)'
          inputs:
            azureSubscription: '$(azureServiceConnection)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              set -e

              RG="$(resourceGroup)"
              ACR="$(acrName)"
              APP="$(appName)"
              LOC="$(location)"
              REPO="$(imageRepository)"
              PORT="$(containerPort)"

              # Pega IMAGE do artifact ou do ACR (última tag)
              if [ -f "$(Pipeline.Workspace)/image_meta/build_vars.txt" ]; then
                . "$(Pipeline.Workspace)/image_meta/build_vars.txt"
              fi
              if [ -z "$IMAGE" ]; then
                TAG=$(az acr repository show-tags -n "$ACR" --repository "$REPO" --top 1 --orderby time_desc -o tsv)
                IMAGE="${ACR}.azurecr.io/${REPO}:${TAG}"
              fi
              echo "IMAGE=$IMAGE"

              # Credenciais do ACR
              ACR_USER=$(az acr credential show -n "$ACR" --query username -o tsv)
              ACR_PASS=$(az acr credential show -n "$ACR" --query passwords[0].value -o tsv)

              # Garante login no ACR (debug amigável)
              az acr login --name "$ACR" >/dev/null

              # DNS único por build
              DNS_LABEL="${APP}$(Build.BuildId)"

              # Remove instância antiga (idempotente)
              az container delete -g "$RG" -n "$APP" --yes --only-show-errors || true

              # Cria container
              az container create \
                -g "$RG" -n "$APP" \
                --os-type Linux \
                --image "$IMAGE" \
                --registry-login-server "${ACR}.azurecr.io" \
                --registry-username "$ACR_USER" \
                --registry-password "$ACR_PASS" \
                --cpu 1 --memory 1.5 \
                --ports $PORT \
                --dns-name-label "$DNS_LABEL" \
                --environment-variables \
                  DB_URL="$(DB_URL)" \
                  DB_USER="$(DB_USER)" \
                  DB_PASSWORD="$(DB_PASSWORD)" \
                --location "$LOC"

              # Lê FQDN e exporta como variável de OUTPUT do passo
              FQDN=$(az container show -g "$RG" -n "$APP" --query "ipAddress.fqdn" -o tsv)
              echo "FQDN=$FQDN"
              echo "##vso[task.setvariable variable=ACI_FQDN;isOutput=true]$FQDN"

        # HEALTH-CHECK: lê o output do passo 'setfqdn'
        - task: Bash@3
          name: health
          displayName: 'Health check (retry)'
          inputs:
            targetType: inline
            script: |
              set -e
              # Usa output do passo "setfqdn"; se vazio, faz fallback pelo az cli
              FQDN="$(setfqdn.ACI_FQDN)"
              if [ -z "$FQDN" ]; then
                echo "FQDN vazio via output; buscando direto no Azure..."
                FQDN=$(az container show -g "$(resourceGroup)" -n "$(appName)" --query "ipAddress.fqdn" -o tsv)
              fi

              PORT="$(containerPort)"
              echo "Checking http://$FQDN:$PORT/actuator/health"

              # 12 tentativas (~1 min)
              for i in {1..12}; do
                if curl -fsS "http://$FQDN:$PORT/actuator/health" | grep -q '"status"'; then
                  echo "OK: app respondeu."
                  exit 0
                fi
                echo "Tentativa $i/12... aguardando..."
                sleep 5
              done

              echo "Health check falhou"
              echo "==== LOGS DO CONTAINER ===="
              az container logs -g "$(resourceGroup)" -n "$(appName)" || true
              exit 1

        # Resumo para evidência
        - task: Bash@3
          displayName: 'Resumo de deploy'
          condition: succeeded()
          inputs:
            targetType: inline
            script: |
              echo "### Deploy ACI" > summary.md
              echo "" >> summary.md
              echo "- **FQDN:** http://$(setfqdn.ACI_FQDN):$(containerPort)" >> summary.md
              echo "- **Imagem:** $(acrLoginServer)/$(imageRepository):$(imageTag)" >> summary.md
              echo "- **Resource Group:** $(resourceGroup)" >> summary.md
              echo "- **Região:** $(location)" >> summary.md

        - task: PublishBuildArtifacts@1
          displayName: 'Publicar evidência'
          inputs:
            PathtoPublish: 'summary.md'
            ArtifactName: 'evidencias'
            publishLocation: 'Container'
